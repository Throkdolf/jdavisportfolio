{"ast":null,"code":"import Work1 from \"../../assets/xv6.png\";\nimport Work2 from \"../../assets/OoOCPU.png\";\nimport Work3 from \"../../assets/portfolio.png\";\nimport Work4 from \"../../assets/bufferoverflow.png\";\nimport Work5 from \"../../assets/Cache.jpg\";\nimport Work6 from \"../../assets/adventure.png\";\nconst Menu = [{\n  id: 1,\n  image: Work1,\n  title: \"XV6 Operating System Modules\",\n  category: \"Systems\",\n  description: `These modules were compromised of four different projects varying in size and complexity. \n                    The first project was to create a backtrace function that would show all previously called functions\n                    on the stack up till just before backtrace was called. I also implemented a system to allow for a dynamic\n                    amount of RAM to be detected because previously in XV6 you could only have a static 8mb of memory. The new detection\n                    system can support up to 4GB because XV6 is a 32bit OS. I did this by reading in the memory records passed to the bootloader\n                    by the memory controller.\n                    The second project was a virtual memory optimization. I implemented a copy-on-write writing policy, where child processes share the\n                    entire memory space of their parent until attempting to write to memory. Upon writing to a shared page the child process would copy all\n                    of its contents and update its page table. I also implemented a lazy zeroing policy, where upon requesting a blank page from memory instead\n                    of zeroing a page out and giving that, all processes share a single zero page and only on writing to the zero page will it clear a page for\n                    the process.\n                    The third project was a beast because I had to implement a scheduler, kernel level threads and a user level threading library. For the scheduler\n                    I implemented first-in-first-out and round robin scehduling polices. Kernel level threads are built by the clone system call which is very similar to\n                    the fork system call except it spawns a copy of a process with its own stack. One of the biggest challenges of this part was fixing all the pointers\n                    in the new stack to prevent the threads from touching one anothers state. Next I implemented the park, setpark, and unpark system calls. These syscalls\n                    are for waking up and putting idle threads to sleep. You need setpark to prevent the lost wakeup problem where a thread is going to sleep even after it has\n                    been woken up. The last part of the project was the user level threading library where I had to implement spinlocks, mutexes, and condition variables.\n                    The fourth and final project was to implement access control in the file system of XV6. I implemented the setuid and getuid systems calls which return the int\n                    value that corresponds to the logged in or change the uid of the current user. The next part was to implement chown allows a files owner to be modified only by \n                    the root or current owner and chmod which allows the root or owner to change read, write, and execute privileges of a file. Next I implemented a login system\n                    where a user would input a username and password. For security reasons would do not directly store the password of a user instead we compute a salted hash and that\n                    we compare against during login. Finally I implemented support for large files by adding addition levels of indirect to the inode and dinode data structures.`\n}, {\n  id: 2,\n  image: Work2,\n  title: \"Out of Order CPU simulator\",\n  category: \"Systems\",\n  description: `This project was a part of my Advanced Computer Architecture course. The goal was to develop a trace driven simulator that could accurately measure the instructions\n                    per clock cycle of an ISA. I had to create data structure for the Reorder buffer (ROB) which tracked the state of instructions in or preparing for execution and the \n                    Register Alias Table (RAT) which tracks the renaming of registers to tags in the ROB. I also had to implement the issue stage which prepares RAT and ROB entries for an\n                    instruction, schedule stage which finds the most revelent ROB entry and marks it ready to execute, writeback stage which broads casts the completion of instructions to update\n                    ROB entries, and the commit stages which marks an instruction as completed and clears its destination register from the RAT.`\n}, /* TODO: Fix Image for this one*/\n{\n  id: 3,\n  image: Work3,\n  title: \"React Portfolio Website\",\n  category: \"Frontend\",\n  description: \"\"\n}, {\n  id: 4,\n  image: Work4,\n  title: \"Cybersecurity Attacks and Defenses\",\n  category: \"Systems\",\n  description: \"\"\n}, {\n  id: 5,\n  image: Work5,\n  title: \"Multileveled Cache Simulator\",\n  category: \"Systems\",\n  description: \"\"\n}, {\n  id: 6,\n  image: Work6,\n  title: \"Ævintýri\",\n  category: \"Backend\",\n  description: \"\"\n}];\nexport default Menu;","map":{"version":3,"names":["Work1","Work2","Work3","Work4","Work5","Work6","Menu","id","image","title","category","description"],"sources":["/Users/jackdavis/Documents/Projects/jdavisportfolio/src/components/portfolio/Menu.jsx"],"sourcesContent":["import Work1 from \"../../assets/xv6.png\"\nimport Work2 from \"../../assets/OoOCPU.png\"\nimport Work3 from \"../../assets/portfolio.png\"\nimport Work4 from \"../../assets/bufferoverflow.png\"\nimport Work5 from \"../../assets/Cache.jpg\"\nimport Work6 from \"../../assets/adventure.png\"\n\nconst Menu = [\n    {\n      id: 1,\n      image: Work1,\n      title: \"XV6 Operating System Modules\",\n      category: \"Systems\",\n      description: `These modules were compromised of four different projects varying in size and complexity. \n                    The first project was to create a backtrace function that would show all previously called functions\n                    on the stack up till just before backtrace was called. I also implemented a system to allow for a dynamic\n                    amount of RAM to be detected because previously in XV6 you could only have a static 8mb of memory. The new detection\n                    system can support up to 4GB because XV6 is a 32bit OS. I did this by reading in the memory records passed to the bootloader\n                    by the memory controller.\n                    The second project was a virtual memory optimization. I implemented a copy-on-write writing policy, where child processes share the\n                    entire memory space of their parent until attempting to write to memory. Upon writing to a shared page the child process would copy all\n                    of its contents and update its page table. I also implemented a lazy zeroing policy, where upon requesting a blank page from memory instead\n                    of zeroing a page out and giving that, all processes share a single zero page and only on writing to the zero page will it clear a page for\n                    the process.\n                    The third project was a beast because I had to implement a scheduler, kernel level threads and a user level threading library. For the scheduler\n                    I implemented first-in-first-out and round robin scehduling polices. Kernel level threads are built by the clone system call which is very similar to\n                    the fork system call except it spawns a copy of a process with its own stack. One of the biggest challenges of this part was fixing all the pointers\n                    in the new stack to prevent the threads from touching one anothers state. Next I implemented the park, setpark, and unpark system calls. These syscalls\n                    are for waking up and putting idle threads to sleep. You need setpark to prevent the lost wakeup problem where a thread is going to sleep even after it has\n                    been woken up. The last part of the project was the user level threading library where I had to implement spinlocks, mutexes, and condition variables.\n                    The fourth and final project was to implement access control in the file system of XV6. I implemented the setuid and getuid systems calls which return the int\n                    value that corresponds to the logged in or change the uid of the current user. The next part was to implement chown allows a files owner to be modified only by \n                    the root or current owner and chmod which allows the root or owner to change read, write, and execute privileges of a file. Next I implemented a login system\n                    where a user would input a username and password. For security reasons would do not directly store the password of a user instead we compute a salted hash and that\n                    we compare against during login. Finally I implemented support for large files by adding addition levels of indirect to the inode and dinode data structures.`, \n    },\n    {\n      id: 2,\n      image: Work2,\n      title: \"Out of Order CPU simulator\",\n      category: \"Systems\",\n      description: `This project was a part of my Advanced Computer Architecture course. The goal was to develop a trace driven simulator that could accurately measure the instructions\n                    per clock cycle of an ISA. I had to create data structure for the Reorder buffer (ROB) which tracked the state of instructions in or preparing for execution and the \n                    Register Alias Table (RAT) which tracks the renaming of registers to tags in the ROB. I also had to implement the issue stage which prepares RAT and ROB entries for an\n                    instruction, schedule stage which finds the most revelent ROB entry and marks it ready to execute, writeback stage which broads casts the completion of instructions to update\n                    ROB entries, and the commit stages which marks an instruction as completed and clears its destination register from the RAT.`,\n    },\n    /* TODO: Fix Image for this one*/\n    {\n      id: 3,\n      image: Work3,\n      title: \"React Portfolio Website\",\n      category: \"Frontend\",\n      description: \"\",\n    },\n    {\n      id: 4,\n      image: Work4,\n      title: \"Cybersecurity Attacks and Defenses\",\n      category: \"Systems\",\n      description: \"\",\n    },\n    {\n      id: 5,\n      image: Work5,\n      title: \"Multileveled Cache Simulator\",\n      category: \"Systems\",\n      description: \"\",\n    },\n    {\n      id: 6,\n      image: Work6,\n      title: \"Ævintýri\",\n      category: \"Backend\",\n      description: \"\",\n    },\n  ];\n  \n\nexport default Menu"],"mappings":"AAAA,OAAOA,KAAK,MAAM,sBAAsB;AACxC,OAAOC,KAAK,MAAM,yBAAyB;AAC3C,OAAOC,KAAK,MAAM,4BAA4B;AAC9C,OAAOC,KAAK,MAAM,iCAAiC;AACnD,OAAOC,KAAK,MAAM,wBAAwB;AAC1C,OAAOC,KAAK,MAAM,4BAA4B;AAE9C,MAAMC,IAAI,GAAG,CACT;EACEC,EAAE,EAAE,CAAC;EACLC,KAAK,EAAER,KAAK;EACZS,KAAK,EAAE,8BAA8B;EACrCC,QAAQ,EAAE,SAAS;EACnBC,WAAW,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,CAAC,EACD;EACEJ,EAAE,EAAE,CAAC;EACLC,KAAK,EAAEP,KAAK;EACZQ,KAAK,EAAE,4BAA4B;EACnCC,QAAQ,EAAE,SAAS;EACnBC,WAAW,EAAE;AACnB;AACA;AACA;AACA;AACI,CAAC,EACD;AACA;EACEJ,EAAE,EAAE,CAAC;EACLC,KAAK,EAAEN,KAAK;EACZO,KAAK,EAAE,yBAAyB;EAChCC,QAAQ,EAAE,UAAU;EACpBC,WAAW,EAAE;AACf,CAAC,EACD;EACEJ,EAAE,EAAE,CAAC;EACLC,KAAK,EAAEL,KAAK;EACZM,KAAK,EAAE,oCAAoC;EAC3CC,QAAQ,EAAE,SAAS;EACnBC,WAAW,EAAE;AACf,CAAC,EACD;EACEJ,EAAE,EAAE,CAAC;EACLC,KAAK,EAAEJ,KAAK;EACZK,KAAK,EAAE,8BAA8B;EACrCC,QAAQ,EAAE,SAAS;EACnBC,WAAW,EAAE;AACf,CAAC,EACD;EACEJ,EAAE,EAAE,CAAC;EACLC,KAAK,EAAEH,KAAK;EACZI,KAAK,EAAE,UAAU;EACjBC,QAAQ,EAAE,SAAS;EACnBC,WAAW,EAAE;AACf,CAAC,CACF;AAGH,eAAeL,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}